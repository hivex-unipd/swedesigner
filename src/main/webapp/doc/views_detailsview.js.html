<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: views/detailsview.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: views/detailsview.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([
    'jquery',
    'underscore',
    'backbone',
    'joint',
    'views/ProjectView'
], function ($, _, Backbone, joint, ProjectView) {

    /**
     * @classdesc `DetailsView` shows the details of an element in one diagram.
     * The diagram can be the main class diagram or a method diagram.
     * In the first case the elements are classes or links between them,
     * so `DetailsView` shows the class name, its attributes and methods, etcetera.
     * In the second case the elements are instruction blocks, so `DetailsView`
     * shows the operands, parameters, or conditions of a block.
     *
     * @module client.view
     * @name DetailsView
     * @class DetailsView
     * @extends {Backbone.View}
     */
    var DetailsView = Backbone.View.extend({

        /**
         * The HTML tag populated by `DetailsView`.
         * @name DetailsView#tagname
         * @type {string}
         */
        tagname: "div",

        /**
         * The class name.
         * @name DetailsView#className
         * @type {string}
         */
        className: "details-view", // inutile?

        /**
         * The DOM element corresponding to `DetailsView`.
         * @name DetailsView#el
         * @type {Object}
         */
        el: {},

        /**
         * ?
         * @private
         * @name DetailsView#mytemplate
         * @function
         */
        mytemplate: _.template($('#item-template').html()),

        /**
         * ?
         * @name DetailsView#inputs
         * @type {Object}
         */
        inputs: {},

        /*events: {
         "click .adda":   "addAttribute",
         "click .addm":  "addMethod",
         "keydown" : "confirm"
         },*/

        //paper: null,

        //templ: _.template($('#class-template').html()),

        /**
         * ?
         * @name DetailsView#events
         * @type {Object}
         */
        events: {
            //'blur .edit': 'confirmEdit'
        },

        /**
         * Initializes `el` with a jQuery object that handles the `#details`
         * div and starts listening to the `ProjectView` events
         * 'Switchgraph' and 'changed-cell'.
         * @name DetailsView#initialize
         * @function
         */
        initialize: function () {

            this.$el = $("#details");
            console.log(ProjectView.paper);
            //this.listenTo(paper, "cellChanged", this.changeModel);


            // occhio
            // this.listenTo(ProjectView.paper, "changed-cell", this.render);
            this.listenTo(ProjectView, "Switchgraph", this.visib);
            // si riesce a passare paper come parametro?
        },

        /**
         * Re-paints the `#details` div after a 'changed-cell' event was
         * fired by the `ProjectView` object. The cell to be rendered
         * is deduced from `ProjectView.paper.selectedCell`.
         * @name DetailsView#render
         * @function
         */
        render: function () {
            console.log("i'm detailsview and i saw your change");
            //this.$el.html(ProjectView.paper.selectedCell.getClassName());

            //this.$el.html(this.mytemplate({title: "titolo molto divino", val:"valore molto animale"}));

            console.log(ProjectView.paper.selectedCell);
            console.log(ProjectView.paper.selectedCell.attributes.keyvalues);
            var c = ProjectView.paper.selectedCell;


            var output = "";




            var fn = function (element) {
                //console.log("no lazy?");
                if(_.isArray(element)) {console.log(element); console.log("Ã¨ array"); _.each(element, fn, this) }
                else  {console.log(element); output += this.mytemplate(element);}
            };

            console.log("ripperoni");
            //c.attributes.keyvalues.forEach(fn);
            _.each(c.attributes.keyvalues, fn, this);

            console.log("finironi");



            // this.$el.html(this.mytemplate({title: "titolo molto divino", val:"valore molto animale"}));
            this.$el.html(output);



            // idee per il binding a due vie: salvarsi in un array inputs i vari input e in qualche modo confirmedit si prende
            // solo quello che gli serve... mi sembra comunque terribilmente inefficiente... che facciamo?
            // bb
            this.delegateEvents(_.extend(this.events, {'keypress .edit': 'confirmEdit'}));



            return this;

        },

        /**
         * Re-paints the `#details` div after a 'Switchgraph' event was
         * fired by the `ProjectView` object.
         * @name DetailsView#visib
         * @function
         */
        visib: function () {
            if (ProjectView.paper.selectedCell)
                this.$el.html(ProjectView.paper.selectedCell.getMethods());
        },

        /**
         * ?
         * @name DetailsView#getDescendantProp
         * @function
         * @param {Object} obj ?
         * @param {Object} desc ?
         */
        getDescendantProp: function(obj, desc) {
            var arr = desc.split(".");
            while (arr.length &amp;&amp; (obj = obj[arr.shift()]));
            return obj;
        },

        /**
         * Logs some event details (?).
         * @name DetailsView#visib
         * @function
         * @param {event} e the action event
         * @private
         */
        confirmEdit: function (e) {
            if (e.which == 13) {
             // fai controllo di dati corretti e aggiorna il graph
             //this.model.set("",this.$('#'));
                console.log(e.target.id);
                console.log(e.target.value);
                console.log(ProjectView.paper.selectedCell);
                //ProjectView.paper.selectedCell.set();
            }
        }
    });
    return DetailsView;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActivityDiagramElement.html">ActivityDiagramElement</a></li><li><a href="AppView.html">AppView</a></li><li><a href="Commands.html">Commands</a></li><li><a href="DetailsView.html">DetailsView</a></li><li><a href="DiagramsCollection.html">DiagramsCollection</a></li><li><a href="NewCellModel.html">NewCellModel</a></li><li><a href="NewCellView.html">NewCellView</a></li><li><a href="ProjectView.html">ProjectView</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Mar 29 2017 17:53:45 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
